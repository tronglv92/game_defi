// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: weapon.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/lib/pq"
)

const blockWeapon = `-- name: BlockWeapon :one
UPDATE weapons 
SET block=TRUE
WHERE id=$1
RETURNING id, name, price, type, img, level, star, nonce, state, block, created_at
`

func (q *Queries) BlockWeapon(ctx context.Context, id int64) (Weapon, error) {
	row := q.db.QueryRowContext(ctx, blockWeapon, id)
	var i Weapon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Type,
		&i.Img,
		&i.Level,
		&i.Star,
		&i.Nonce,
		&i.State,
		&i.Block,
		&i.CreatedAt,
	)
	return i, err
}

const createTransactionWeapon = `-- name: CreateTransactionWeapon :one
INSERT INTO transaction_weapon(
  weapon_id,
  token_id,
  hash,
  from_address,
  to_address,
  price
)VALUES(
   $1, $2,$3,$4,$5,$6
) 
RETURNING id, weapon_id, token_id, hash, from_address, to_address, price, transaction_at, created_at
`

type CreateTransactionWeaponParams struct {
	WeaponID    int64  `json:"weapon_id"`
	TokenID     int64  `json:"token_id"`
	Hash        string `json:"hash"`
	FromAddress string `json:"from_address"`
	ToAddress   string `json:"to_address"`
	Price       int64  `json:"price"`
}

func (q *Queries) CreateTransactionWeapon(ctx context.Context, arg CreateTransactionWeaponParams) (TransactionWeapon, error) {
	row := q.db.QueryRowContext(ctx, createTransactionWeapon,
		arg.WeaponID,
		arg.TokenID,
		arg.Hash,
		arg.FromAddress,
		arg.ToAddress,
		arg.Price,
	)
	var i TransactionWeapon
	err := row.Scan(
		&i.ID,
		&i.WeaponID,
		&i.TokenID,
		&i.Hash,
		&i.FromAddress,
		&i.ToAddress,
		&i.Price,
		&i.TransactionAt,
		&i.CreatedAt,
	)
	return i, err
}

const createWeapon = `-- name: CreateWeapon :one
INSERT INTO weapons (
  name, price,type,img,level,star,nonce,state
) VALUES (
  $1, $2,$3,$4,$5,$6,$7,$8
)
RETURNING id, name, price, type, img, level, star, nonce, state, block, created_at
`

type CreateWeaponParams struct {
	Name  string `json:"name"`
	Price int64  `json:"price"`
	Type  int64  `json:"type"`
	Img   string `json:"img"`
	Level int64  `json:"level"`
	Star  int64  `json:"star"`
	Nonce int64  `json:"nonce"`
	State int64  `json:"state"`
}

func (q *Queries) CreateWeapon(ctx context.Context, arg CreateWeaponParams) (Weapon, error) {
	row := q.db.QueryRowContext(ctx, createWeapon,
		arg.Name,
		arg.Price,
		arg.Type,
		arg.Img,
		arg.Level,
		arg.Star,
		arg.Nonce,
		arg.State,
	)
	var i Weapon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Type,
		&i.Img,
		&i.Level,
		&i.Star,
		&i.Nonce,
		&i.State,
		&i.Block,
		&i.CreatedAt,
	)
	return i, err
}

const createWeaponAbility = `-- name: CreateWeaponAbility :one
INSERT INTO weapon_abilities(
  weapon_id,img,name,description,level
)VALUES(
   $1, $2,$3,$4,$5
) 
RETURNING id, weapon_id, img, name, description, level, created_at
`

type CreateWeaponAbilityParams struct {
	WeaponID    int64  `json:"weapon_id"`
	Img         string `json:"img"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Level       int64  `json:"level"`
}

func (q *Queries) CreateWeaponAbility(ctx context.Context, arg CreateWeaponAbilityParams) (WeaponAbility, error) {
	row := q.db.QueryRowContext(ctx, createWeaponAbility,
		arg.WeaponID,
		arg.Img,
		arg.Name,
		arg.Description,
		arg.Level,
	)
	var i WeaponAbility
	err := row.Scan(
		&i.ID,
		&i.WeaponID,
		&i.Img,
		&i.Name,
		&i.Description,
		&i.Level,
		&i.CreatedAt,
	)
	return i, err
}

const createWeaponNFT = `-- name: CreateWeaponNFT :one
INSERT INTO weapon_nft(
  weapon_id,
  token_id,
  address_owner
)VALUES(
   $1, $2,$3
) 
RETURNING id, weapon_id, token_id, address_owner, created_at
`

type CreateWeaponNFTParams struct {
	WeaponID     int64  `json:"weapon_id"`
	TokenID      int64  `json:"token_id"`
	AddressOwner string `json:"address_owner"`
}

func (q *Queries) CreateWeaponNFT(ctx context.Context, arg CreateWeaponNFTParams) (WeaponNft, error) {
	row := q.db.QueryRowContext(ctx, createWeaponNFT, arg.WeaponID, arg.TokenID, arg.AddressOwner)
	var i WeaponNft
	err := row.Scan(
		&i.ID,
		&i.WeaponID,
		&i.TokenID,
		&i.AddressOwner,
		&i.CreatedAt,
	)
	return i, err
}

const createWeaponStat = `-- name: CreateWeaponStat :one
INSERT INTO weapon_stats(
  weapon_id,damage,speed,hp,critical
)VALUES(
   $1, $2,$3,$4,$5
) 
RETURNING id, weapon_id, damage, speed, hp, critical, created_at
`

type CreateWeaponStatParams struct {
	WeaponID int64  `json:"weapon_id"`
	Damage   string `json:"damage"`
	Speed    string `json:"speed"`
	Hp       string `json:"hp"`
	Critical string `json:"critical"`
}

func (q *Queries) CreateWeaponStat(ctx context.Context, arg CreateWeaponStatParams) (WeaponStat, error) {
	row := q.db.QueryRowContext(ctx, createWeaponStat,
		arg.WeaponID,
		arg.Damage,
		arg.Speed,
		arg.Hp,
		arg.Critical,
	)
	var i WeaponStat
	err := row.Scan(
		&i.ID,
		&i.WeaponID,
		&i.Damage,
		&i.Speed,
		&i.Hp,
		&i.Critical,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAblitity = `-- name: DeleteAblitity :exec
DELETE FROM weapon_abilities WHERE weapon_id=$1
`

func (q *Queries) DeleteAblitity(ctx context.Context, weaponID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAblitity, weaponID)
	return err
}

const deleteStat = `-- name: DeleteStat :exec
DELETE FROM weapon_stats WHERE weapon_id=$1
`

func (q *Queries) DeleteStat(ctx context.Context, weaponID int64) error {
	_, err := q.db.ExecContext(ctx, deleteStat, weaponID)
	return err
}

const filterWeapon = `-- name: FilterWeapon :many
select  row_to_json(row)
from (
    select id, name, price, type, img, level, star, nonce, state, created_at, abilities, stat from view_weapons
    WHERE (CASE WHEN $3::bool THEN star = ANY($4::bigint[]) ELSE TRUE END)
    AND (CASE WHEN $5::bool THEN type = ANY($6::bigint[])  ELSE TRUE END)
    AND (CASE
          WHEN $7::bool THEN price BETWEEN $8 AND $9  
          WHEN $10::bool THEN price >= $8
          WHEN $11::bool THEN price <= $9
      ELSE TRUE END)
    ORDER BY id
    LIMIT $1
    OFFSET $2
    
) row
`

type FilterWeaponParams struct {
	Limit          int32   `json:"limit"`
	Offset         int32   `json:"offset"`
	Isstar         bool    `json:"isstar"`
	Star           []int64 `json:"star"`
	Istype         bool    `json:"istype"`
	Type           []int64 `json:"type"`
	Ispricebetween bool    `json:"ispricebetween"`
	Pricefrom      int64   `json:"pricefrom"`
	Priceto        int64   `json:"priceto"`
	Ispricefrom    bool    `json:"ispricefrom"`
	Ispriceto      bool    `json:"ispriceto"`
}

func (q *Queries) FilterWeapon(ctx context.Context, arg FilterWeaponParams) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, filterWeapon,
		arg.Limit,
		arg.Offset,
		arg.Isstar,
		pq.Array(arg.Star),
		arg.Istype,
		pq.Array(arg.Type),
		arg.Ispricebetween,
		arg.Pricefrom,
		arg.Priceto,
		arg.Ispricefrom,
		arg.Ispriceto,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []json.RawMessage{}
	for rows.Next() {
		var row_to_json json.RawMessage
		if err := rows.Scan(&row_to_json); err != nil {
			return nil, err
		}
		items = append(items, row_to_json)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWeaponByOwnerAddress = `-- name: FindWeaponByOwnerAddress :many
select  row_to_json(row)
from (
    select view_weapons.id, name, price, type, img, level, star, nonce, state, view_weapons.created_at, abilities, stat, weapon_nft.id, weapon_id, token_id, address_owner, weapon_nft.created_at from view_weapons 
    INNER JOIN weapon_nft ON view_weapons.id=weapon_nft.weapon_id 
    WHERE 
      weapon_nft.address_owner=$3
    ORDER BY view_weapons.id
    LIMIT $1
    OFFSET $2
    
) row
`

type FindWeaponByOwnerAddressParams struct {
	Limit        int32  `json:"limit"`
	Offset       int32  `json:"offset"`
	AddressOwner string `json:"address_owner"`
}

func (q *Queries) FindWeaponByOwnerAddress(ctx context.Context, arg FindWeaponByOwnerAddressParams) ([]json.RawMessage, error) {
	rows, err := q.db.QueryContext(ctx, findWeaponByOwnerAddress, arg.Limit, arg.Offset, arg.AddressOwner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []json.RawMessage{}
	for rows.Next() {
		var row_to_json json.RawMessage
		if err := rows.Scan(&row_to_json); err != nil {
			return nil, err
		}
		items = append(items, row_to_json)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWeaponByPK = `-- name: FindWeaponByPK :one

select  row_to_json(row)
from (
    select id, name, price, type, img, level, star, nonce, state, created_at, abilities, stat from view_weapons WHERE id = $1
) row LIMIT 1
`

// -- name: FindWeaponByPK :one
// SELECT sqlc.embed(weapon_abilities.*),weapons.id FROM weapons
// INNER JOIN weapon_abilities ON weapons.id=weapon_abilities.weapon_id
// WHERE weapons.id = $1 AND weapons.state = $2 LIMIT 1;
func (q *Queries) FindWeaponByPK(ctx context.Context, id int64) (json.RawMessage, error) {
	row := q.db.QueryRowContext(ctx, findWeaponByPK, id)
	var row_to_json json.RawMessage
	err := row.Scan(&row_to_json)
	return row_to_json, err
}

const unBlockWeapon = `-- name: UnBlockWeapon :one
UPDATE weapons 
SET block=FALSE
WHERE id=$1
RETURNING id, name, price, type, img, level, star, nonce, state, block, created_at
`

func (q *Queries) UnBlockWeapon(ctx context.Context, id int64) (Weapon, error) {
	row := q.db.QueryRowContext(ctx, unBlockWeapon, id)
	var i Weapon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Type,
		&i.Img,
		&i.Level,
		&i.Star,
		&i.Nonce,
		&i.State,
		&i.Block,
		&i.CreatedAt,
	)
	return i, err
}

const updateAblitity = `-- name: UpdateAblitity :one
UPDATE weapon_abilities 
SET img=$1,name=$2,description=$3,level=$4
WHERE id=$5
RETURNING id, weapon_id, img, name, description, level, created_at
`

type UpdateAblitityParams struct {
	Img         string `json:"img"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Level       int64  `json:"level"`
	ID          int64  `json:"id"`
}

func (q *Queries) UpdateAblitity(ctx context.Context, arg UpdateAblitityParams) (WeaponAbility, error) {
	row := q.db.QueryRowContext(ctx, updateAblitity,
		arg.Img,
		arg.Name,
		arg.Description,
		arg.Level,
		arg.ID,
	)
	var i WeaponAbility
	err := row.Scan(
		&i.ID,
		&i.WeaponID,
		&i.Img,
		&i.Name,
		&i.Description,
		&i.Level,
		&i.CreatedAt,
	)
	return i, err
}

const updateStat = `-- name: UpdateStat :one
UPDATE weapon_stats 
SET damage=$1,speed=$2,hp=$3,critical=$4
WHERE id=$5
RETURNING id, weapon_id, damage, speed, hp, critical, created_at
`

type UpdateStatParams struct {
	Damage   string `json:"damage"`
	Speed    string `json:"speed"`
	Hp       string `json:"hp"`
	Critical string `json:"critical"`
	ID       int64  `json:"id"`
}

func (q *Queries) UpdateStat(ctx context.Context, arg UpdateStatParams) (WeaponStat, error) {
	row := q.db.QueryRowContext(ctx, updateStat,
		arg.Damage,
		arg.Speed,
		arg.Hp,
		arg.Critical,
		arg.ID,
	)
	var i WeaponStat
	err := row.Scan(
		&i.ID,
		&i.WeaponID,
		&i.Damage,
		&i.Speed,
		&i.Hp,
		&i.Critical,
		&i.CreatedAt,
	)
	return i, err
}

const updateStateWeapon = `-- name: UpdateStateWeapon :one
UPDATE weapons 
SET state=$1
WHERE id=$2
RETURNING id, name, price, type, img, level, star, nonce, state, block, created_at
`

type UpdateStateWeaponParams struct {
	State int64 `json:"state"`
	ID    int64 `json:"id"`
}

func (q *Queries) UpdateStateWeapon(ctx context.Context, arg UpdateStateWeaponParams) (Weapon, error) {
	row := q.db.QueryRowContext(ctx, updateStateWeapon, arg.State, arg.ID)
	var i Weapon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Type,
		&i.Img,
		&i.Level,
		&i.Star,
		&i.Nonce,
		&i.State,
		&i.Block,
		&i.CreatedAt,
	)
	return i, err
}

const updateWeapon = `-- name: UpdateWeapon :one
UPDATE weapons 
SET name=$1, price=$2,type=$3,img=$4,level=$5,star=$6,nonce=$7
WHERE id=$8
RETURNING id, name, price, type, img, level, star, nonce, state, block, created_at
`

type UpdateWeaponParams struct {
	Name  string `json:"name"`
	Price int64  `json:"price"`
	Type  int64  `json:"type"`
	Img   string `json:"img"`
	Level int64  `json:"level"`
	Star  int64  `json:"star"`
	Nonce int64  `json:"nonce"`
	ID    int64  `json:"id"`
}

func (q *Queries) UpdateWeapon(ctx context.Context, arg UpdateWeaponParams) (Weapon, error) {
	row := q.db.QueryRowContext(ctx, updateWeapon,
		arg.Name,
		arg.Price,
		arg.Type,
		arg.Img,
		arg.Level,
		arg.Star,
		arg.Nonce,
		arg.ID,
	)
	var i Weapon
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Price,
		&i.Type,
		&i.Img,
		&i.Level,
		&i.Star,
		&i.Nonce,
		&i.State,
		&i.Block,
		&i.CreatedAt,
	)
	return i, err
}

const updateWeaponNFT = `-- name: UpdateWeaponNFT :one
UPDATE weapon_nft 
SET address_owner=$1
WHERE id=$2
RETURNING id, weapon_id, token_id, address_owner, created_at
`

type UpdateWeaponNFTParams struct {
	AddressOwner string `json:"address_owner"`
	ID           int64  `json:"id"`
}

func (q *Queries) UpdateWeaponNFT(ctx context.Context, arg UpdateWeaponNFTParams) (WeaponNft, error) {
	row := q.db.QueryRowContext(ctx, updateWeaponNFT, arg.AddressOwner, arg.ID)
	var i WeaponNft
	err := row.Scan(
		&i.ID,
		&i.WeaponID,
		&i.TokenID,
		&i.AddressOwner,
		&i.CreatedAt,
	)
	return i, err
}
